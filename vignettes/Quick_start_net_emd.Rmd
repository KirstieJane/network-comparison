---
title: "Quick start guide for NetEMD"
author: "Martin O'Reilly"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quick start for NetEMD}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Virus PPI example for NetEMD
```{r, fig.show='hold'}
library("netdist")
# Set source directory and file properties for Virus PPI graph edge files
source_dir <- system.file(file.path("extdata", "VRPINS"), package = "netdist")
edge_format = "ncol"
file_pattern = ".txt"

# Set number of threads to use at once for parallel processing. To fully utilise
# a modern consumer processor, this should be set to 2x the number of available
# processor cores as each core supports two threads. The getOption() function
# will take this from the local R environment if set there. Otherwise it 
# assumes 1 core, so sets 2 threads.
num_threads = getOption("mc.cores", 2L)

# Calculate graphlet-based degree distributions for all orbits in graphlets 
# comprising up to 4 nodes for all graphs. This only needs to be done once 
# per graph (feature_type = "orbit", max_graphlet_size = 4).. 
# If feature_type is set to "feature_type", orbit counts for orbits in the
# same graphlet will be summed to generate graphlet counts
# If max_graphlet_size is set to 5, graphlet-based degree distributions will  
# be calculated for graphlets comprising up to 5 nodes.
virus_gdds <- gdd_for_all_graphs(
  source_dir = source_dir, feature_type = "orbit", max_graphlet_size = 4,
  format = edge_format, pattern = file_pattern, mc.cores = num_threads)
names(virus_gdds)

# Compute NetEMDs between all virus PPI graphs based on the computed graphlet- 
# based degree distributions using the default fast "optimise" method and no
# smoothing (default). The "optimise" method uses the built-in R optimise
# function to efficiently find the offset with the minimum EMD, but is not
# guaranteed to find the global minimum if EMD as a function of offset
# is non-convex and/or multimodal. The smoothing window width determines 
# whether to calculate the NetEMD from the unaltered discrete GDD histograms
# (smoothing_window_width = 0; default) or to first apply "nearest neighbour" 
# smoothing by "smearing" the discrete GDD histogram point masses across bins 
# of unit width (smoothing_window_width = 1). In this example we choose to 
# return only the NetEMDs between each pair of histograms, so set return_details 
# = FALSE (default), which returns a named list containing (i) the NetEMDs 
# and (ii) a table containing the graph names and indices within the input 
# GDD list for each pair of graphs compared. When return_details = TRUE the
# returned list contains the following additional matrix elements for each 
# graph pair: (iii) the minimal EMD for each GDD used to compute the NetEMD  
# and (iv) the offsets associated with these minimal GDD EMDs.
out <- net_emds_for_all_graphs(
  gdds = virus_gdds, method = "optimise", smoothing_window_width = 0, 
  return_details = FALSE, mc.cores = num_threads)
print(out$net_emds)

# You can also specify method = "fixed_step" to use the much slower method of 
# exhaustively evaluating the EMD at all offsets separated by a fixed step. 
# The default step size is 1/2 the the minimum spacing between locations in 
# either histogram after normalising to unit variance. However, you can 
# specifiy your own fixed step using the optional "step_size" parameter.
# Note that this step size is applied to the histograms after they have been 
# normalised to unit variance

# Display NetEMDs for all network pairs, alongside the details of the network pairs
print(cbind(out$comp_spec, out$net_emds))

# Confirm NetEMD of a graph with itself is zero within (or at least close to)
# the limits of machine precision
purrr::map2(virus_gdds, virus_gdds, net_emd)
.Machine$double.eps
```

