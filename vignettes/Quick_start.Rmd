---
title: "Quick start"
author: "Martin O'Reilly"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Quick start}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---
## Virus PPI example (from sample data)
```{r, fig.show='hold'}
library("netdist")
# Load example virus PPI graphs from files
virus_edges <- read_all_graphs_as_orca_edge_lists(
  system.file(package = "netdist", "extdata", "VRPINS"),
  format = "ncol", pattern = ".txt")
attr(virus_edges, "names")

# Calculate graphlet orbit degree distributions for graphlets comprising up to 
# 4 nodes for all graphs This only needs to be done once per graph. 
# If type is set to "node5", graphlet orbit degree distributions will be 
# calculated for graphlets comprising up to 5 nodes
virus_godd <- purrr::map(virus_edges, godd, type = "node4")

# Generate a cross-comparison matrix listing all combinations of graphs
comp_spec <- graph_cross_comparison_spec(virus_edges)
comp_spec[1:5,]

# Compute NetEMD between all virus PPI graphs based on the computed graphlet 
# orbit degree distributions, using the fast "optimise" method (default). This
# method uses the built-in R optimise method to efficiently find the offset
# with the minimum EMD, but is not guaranteed to find the global minimum if
# EMD as a function of offset is multimodal.
net_emds <- purrr::simplify(
  purrr::map2(comp_spec$index_a, comp_spec$index_b, function(index_a, index_b) {
  net_emd(virus_godd[[index_a]], virus_godd[[index_b]], method = "optimise")
}))
print(net_emds)

# You can also specify method = "fixed_step" to use the much slower method of 
# exhaustively evaluating the EMD at all offsets separated by a fixed step. 
# The default step size is 1/2 the the minimum spacing between locations in 
# either histogram after normalising to unit variance. However, you can 
# specifiy your own fixed step using the optional "step_size" parameter.
# Note that this step size is applied to the histograms after they have been 
# normalised to unit variance

# Link NetEMDs with their respective comp_specs
comp_spec$net_emd = net_emds
print(comp_spec)

# Confirm NetEMD of a graph with itself is zero within (or at least close to)
# the limits of machine precision
purrr::map2(virus_godd, virus_godd, net_emd)
.Machine$double.eps
```

